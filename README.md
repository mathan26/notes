Study notes From June 6 2020
-------------------------------------------------------------------------------------------------------------------------------------------

<h2>JUnit</h2>
<img src="https://github.com/mathan26/notes/blob/master/Images/0%20Junit%20agenta.PNG"/>
<img src="https://github.com/mathan26/notes/blob/master/Images/1%20what%20is%20Junit.PNG"/>
<img src="https://github.com/mathan26/notes/blob/master/Images/2%20Advantages%20of%20Junit.PNG"/>
<img src=https://github.com/mathan26/notes/blob/master/Images/3%20Junit%20features.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/4%20TheJunitFrameWork.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/5%20TheTextFixures.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/6%20TheTestSuites.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/7%20TestRunners.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/8%20Junit%20Classes.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/9%20CodeatTest1.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/10%20JunitCoreClass.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/11%20JunitAnnotationandAssertStmnts.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/12%20JunitAnnotationandAssertStmnts2.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/13%20Exception.PNG/>
<img src=  https://github.com/mathan26/notes/blob/master/Images/15%20JunitVsTestNG.PNG/>

<h2>React Full Stack Application</h2>
<hr></hr>

#WebHook
<hr></hr>

```One Server makes request to another server at any time because of some evenet```
https://sendgrid.com/blog/whats-webhook/

#Localtunnel (just for reference)
<hr></hr>

```Localtunnel allows you to easily share a web service on your local development machine without messing with DNS and firewall settings``` 
  
 ```  Localtunnel will assign you a unique publicly accessible url that will proxy all requests to your locally running webserver```
https://localtunnel.github.io/www/

#Ngrok setup instead of LocalTunnel
<hr></hr>

```npx ngrok http 5000```

<p>After running the above command Forward URL will be generated by ngork.
This is valid only for 8 hours.
Once Server stopped ,need to generate again.
  <img src="https://github.com/mathan26/notes/blob/master/Images/16%20ngork.PNG"/>
</p>
https://ngrok.com/

<hr/>

# React

1 What is React? What is it purpose?

```React is a JavaScript library used to show the HTML content to the user and handle the User Interaction.```
```But it can also work with tremendous libraries, packages and servers to make React even more poerful```

2 How to make React Components?

```React Components Made using either JavaScript functions or classes``` 

3 What was the HTML or JSX looking stuff?

``` It's look like html and placed between the JS.It is converted to HTML code when rendering the Components``` 

4 How to handle the User Interaction with the components?

```Event handlers are used to detect the User Interaction and respond to it.``` 

5 What is React and React-DOM in the import section do?

```React knows what components is and how to make component work together```
```ReactDOM knows how to take components and make it show up in the DOM.```

6 How to create React Project?

```npx create-react-app app-name```
```It provides default setup WebPack, Babel, Dev Server.No need to Setup manually.```

# Data Structures and Algorithms

 1 Introduction
 * Variables 
 * Data Types
 
    ![Data Types In Java(/Images/17 Data Types In Java.PNG)
    
 * Data Structures 
 
   *Once we have data that is stored in the variable we need some mechanism to manipulate the data,*
  
   > Data Structure is a way of storing and organizing data in a computer, so that it can be used efficiently.
   
   Depending on the organization of elements ,DS classified into two types:     
   1 Linear Data Structures
    > Elements are accessed in a sequential order.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
   2 Non Linear Data Structures
   > Elements of this DS stored/accessed in a non-linear order. 
   
* Abstract Data Type
    > To Simplify the process of solving problems ,we combine the data structures with their operations
    > and are called ADT.
   * Two Parts:    
        * Declaration of Data 
        * Declaration of Operations
* Algorithm
    > An Algorithm is step-by-step instructions to solve a given problem.   
* Analysis of Algorithm
    > It helps us to find which of them is efficient in terms of time and space consumed.
* Goal of Analysis of Algorithm
    >Compare the Algorithms of different solutions.
* Running Time Analysis
    > It is the process of determining how process time increase as the size of the problem.
* Compare Algorithms
    > Running time of given algorithm as a function of input size n.
* Rate of Growth
    > The rate at which running time increase as a function of input is called rate of growth.
    We can igore the small terms when compare with big terms.

* Commonly used Rate of Growths
    
   Time Complexity | Name | Example 
   ------------ | ------------- | -------------
   1 | Constant | Adding Element in the front of the list
   logn | Logarithmic | Finding an element in sorted array
   n | Linear | Finding an element in unsorted array
   nlogn | Linear Logarithmic | sorting n items by 'divide-and-conquer' Mergesort
   n^2 | Quadratic | Shortest path between two nodes in a graph.
   n^3 | cubic | Matrix Multiplication
   2^n | Exponential | The Towers of Hanoi problem
   
  * Comparison from low to high processing,
    > 1 < log log n < âˆšlogn < log^2 n < 2^logn < n < log(n!) < n log n < n^2 < 2^n < 4^ < n! <2^2n
      
      
      
* Types of Analysis
    * To analysis the algorithm we need to know what input algorithm takes less time and on what inputs
    it takes huge time.
    * Three types
        * Worst Case (Big O)
            * Defines the input for which algorithm takes huge time.
            * Input is the one for which the algorithm runs slower
        * Best case (Big Omega)
            * Defines the input for which algorithm takes less time
         * Average Case (Theta)
            * Provides prediction about the running time of algorithm
            * input is random.
* Asymptotic Notation
    > Expression for Best ,Worst and Average
* Big-O Notation
    > Find tight upper bound of the given function.The function , f(n) = O(g(n)) iff +ve Constants C and n0
    > such that 
                   
                  f(n) <= C*g(n) for All n>= n0
    
    Example:
        f(n) = 2n + 3
        <br/>
        2n + 3 <= 10n n>=1
    Here C = 10, g(n) = n
    <code> 2n + 3 < = 2n + 3n=5n</code>
          Therefore 
    ```f(n)=O(n)```
    
    * In big-O write closest function i.e near of growth rate of f(n)

# LinkedList

* Successive elements are connected by pointers
* last elements points to null.
* It can shrink or grown execution of the program.
* It doesn't waste memory space.

# LinkedList ADT
* Main
    * Insert
    * Delete
* Auxiliary
    * Delete List
    * Count
    * Find nth

* Why constant time for accessing array elemens?
    * We already know the base address ,using the offset we can find any value.
    * So it takes constant time.
    
        * Advantage of Arrays:
            * simple and easy to use.
            * Faster access to the elements
        * Disadvantage:
            * Fixed size
            * One block allocation
            * Complex position-based insertion
        * Advantage of LinkedList
            * Expanded at constant time.
        * Disadvantage of LinkedList
            * Linear access
            * Hard to manipulate
            * Extra space for memory.
    
    * LinkedList Representation in Java
    
    ```
          class LinkedList {
           Node head; // head of the list
       
           /* Linked list Node*/
           class Node {
               int data;
               Node next;
       
               // Constructor to create a new node
               // Next is by default initialized
               // as null
               Node(int d) { data = d; }
           }
       }
  ```
  * In LinkedList data can be added in,
  
    1  At the front of the linked list
    
    ```
    public void push(int new_data) 
    { 
        /* 1 & 2: Allocate the Node & 
                  Put in the data*/
        Node new_node = new Node(new_data); 
      
        /* 3. Make next of new Node as head */
        new_node.next = head; 
      
        /* 4. Move the head to point to new Node */
        head = new_node; 
    } 
    ```
    > Time complexity of push() is O(1) as it does constant amount of work.
    
    2  After a given node.  
    
    ```
    public void insertAfter(Node prev_node, int new_data) 
    { 
        /* 1. Check if the given Node is null */
        if (prev_node == null) 
        { 
            System.out.println("The given previous node cannot be null"); 
            return; 
        } 
      
        /* 2. Allocate the Node & 
           3. Put in the data*/
        Node new_node = new Node(new_data); 
      
        /* 4. Make next of new Node as next of prev_node */
        new_node.next = prev_node.next; 
      
        /* 5. make next of prev_node as new_node */
        prev_node.next = new_node; 
    } 
    ```
    > Time complexity of insertAfter() is O(1) as it does constant amount of work.
      
    3  At the end of the linked list.
    
    ```
    /* Appends a new node at the end.  This method is  
       defined inside LinkedList class shown above */
    public void append(int new_data) 
    { 
        /* 1. Allocate the Node & 
           2. Put in the data 
           3. Set next as null */
        Node new_node = new Node(new_data); 
      
        /* 4. If the Linked List is empty, then make the 
               new node as head */
        if (head == null) 
        { 
            head = new Node(new_data); 
            return; 
        } 
      
        /* 4. This new node is going to be the last node, so 
             make next of it as null */
        new_node.next = null; 
      
        /* 5. Else traverse till the last node */
        Node last = head;  
        while (last.next != null) 
            last = last.next; 
      
        /* 6. Change the next of last node */
        last.next = new_node; 
        return; 
    } 
    ```
    
    > Time complexity of append is O(n) where n is the number of nodes in linked list. Since there is a loop from head to end, the function does O(n) work.
      This method can also be optimized to work in O(1) by keeping an extra pointer to tail of linked list

#### Doubly Linked List

* Advantage
  * We can navigate in both the direction.
  * Each Node has left and Right pointers, no need to keep pre pointer for delete operation.
* Disadvantage
  * Extra memory space
  * More pointer operation
  
  ```
    // Class for Doubly Linked List 
    public class DLL { 
        Node head; // head of list 
      
        /* Doubly Linked list Node*/
        class Node { 
            int data; 
            Node prev; 
            Node next; 
      
            // Constructor to create a new node 
            // next and prev is by default initialized as null 
            Node(int d) { data = d; } 
        } 
    } 
  ```

### Circular Linked list
  * All node are connected to form a circle.
    
    * Advantage
        * Any node can be starting point, need to stop when first visited node is visited again.
        * Useful for implementation of Queue.
    * Application
        * it is used in the application when repeatedly go around the list. Ex: OS managing list of application.
      
      
   
```
static void traverse(Node last) 
{ 
    Node p; 
  
    // If list is empty, return. 
    if (last == null) 
    { 
        System.out.println("List is empty."); 
        return; 
    } 
  
    // Pointing to first Node of the list. 
    p = last.next; 
  
    // Traversing the list. 
    do
    { 
        System.out.print(p.data + " "); 
        p = p.next; 
  
    } 
    while(p != last.next); 
  
} 
```  


# Java 8
## Predefined Functional Interfaces
### Predicates
* It is a functional interface which has single method  test it accepts single argument and returns a boolean value.
* It is available in the java.util.function package.

```
    interface Predicate<T> {
             public boolean test(T t);
    }
```
* It is a functional interface, so it can refer lamda expression.

> *Write a predicate to check whether the given integer is greater than 10 or not.*

> Actual Signature,
```
Predicate<Integer> p = new Predicate<Integer>() {
            @Override
            public boolean test(Integer I) {
                return I>10 ;
            }
        };
```

> Using Lamda Expression,

```
    Predicate<Integer> p = I->(I>10);  
```

#### Predicate Joining

* We can also join the predicate conditions and get the results by using below methods,
    * p.and(p2);
    * p.or(p2);
    * p.negate();

### Functions
* It is similar to predicates, but functions can return any type.
* But it will return only one value based on the type we provided.
* it contains only one method i.e apply()

> Signature
  
  argument 1 - Processing value
  argument 2 - Return Type
  
```
    Function<String,Integer> function =new Function<String, Integer>() {
            @Override
            public Integer apply(String s) {
                return s.length();
            }
        };
        
```

> Lamda Signature

```
 Function<String,Integer> f1 = s -> s.length();
```

#### Function chaning

* We can combine the Functions and get the results,
  * f1.andThen(f2).apply(); // f1 will execute first then f2 will execute
  * f1.compose(f2).apply();  // first f2 will be applied then f1 will execute
  
 #### Function Interface static method: identity()
 
  * Returns a function that always returns it's input argument.
```
Function<String,String> f2= Function.identity();
```
